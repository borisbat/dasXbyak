// this file is generated via daScript automatic C++ binder
// all user modifications will be lost after this file is re-generated

template <> struct cast_arg<Xbyak::Allocator> {
	static __forceinline const Xbyak::Allocator & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Allocator *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Operand> {
	static __forceinline const Xbyak::Operand & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Operand *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Reg> {
	static __forceinline const Xbyak::Reg & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Reg *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Reg8> {
	static __forceinline const Xbyak::Reg8 & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Reg8 *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Reg16> {
	static __forceinline const Xbyak::Reg16 & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Reg16 *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Mmx> {
	static __forceinline const Xbyak::Mmx & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Mmx *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::EvexModifierRounding> {
	static __forceinline const Xbyak::EvexModifierRounding & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::EvexModifierRounding *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::EvexModifierZero> {
	static __forceinline const Xbyak::EvexModifierZero & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::EvexModifierZero *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Xmm> {
	static __forceinline const Xbyak::Xmm & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Xmm *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Ymm> {
	static __forceinline const Xbyak::Ymm & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Ymm *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Zmm> {
	static __forceinline const Xbyak::Zmm & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Zmm *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Tmm> {
	static __forceinline const Xbyak::Tmm & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Tmm *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Opmask> {
	static __forceinline const Xbyak::Opmask & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Opmask *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::BoundsReg> {
	static __forceinline const Xbyak::BoundsReg & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::BoundsReg *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Fpu> {
	static __forceinline const Xbyak::Fpu & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Fpu *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Reg32e> {
	static __forceinline const Xbyak::Reg32e & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Reg32e *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Reg32> {
	static __forceinline const Xbyak::Reg32 & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Reg32 *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Reg64> {
	static __forceinline const Xbyak::Reg64 & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Reg64 *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::RegRip> {
	static __forceinline const Xbyak::RegRip & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::RegRip *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Segment> {
	static __forceinline const Xbyak::Segment & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Segment *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::RegExp> {
	static __forceinline const Xbyak::RegExp & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::RegExp *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::CodeArray> {
	static __forceinline const Xbyak::CodeArray & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::CodeArray *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Address> {
	static __forceinline const Xbyak::Address & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Address *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::AddressFrame> {
	static __forceinline const Xbyak::AddressFrame & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::AddressFrame *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::JmpLabel> {
	static __forceinline const Xbyak::JmpLabel & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::JmpLabel *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::Label> {
	static __forceinline const Xbyak::Label & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::Label *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::LabelManager> {
	static __forceinline const Xbyak::LabelManager & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::LabelManager *>::to(res);
	}
};
template <> struct cast_arg<Xbyak::CodeGenerator> {
	static __forceinline const Xbyak::CodeGenerator & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Xbyak::CodeGenerator *>::to(res);
	}
};
